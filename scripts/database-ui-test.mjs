#!/usr/bin/env node

import { dirname, join } from "path";
import puppeteer from "puppeteer";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Konfiguracja test√≥w
const CONFIG = {
  APP_URL: "http://localhost:5173",
  BACKEND_URL: "http://localhost:3001",
  HEADLESS: false,
  SLOW_MO: 250,
  TIMEOUT: 30000,
  SCREENSHOT_DIR: join(__dirname, "..", "screenshots"),
  TEST_DATA: {
    project: {
      name: `Test Project ${Date.now()}`,
      description: "Automatyczny test projektu",
      client: "Test Client",
    },
    client: {
      name: `Test Client ${Date.now()}`,
      email: "test@example.com",
      phone: "+48123456789",
    },
    material: {
      name: `Test Material ${Date.now()}`,
      type: "p≈Çyta",
      thickness: "18mm",
      supplier: "Test Supplier",
    },
  },
};

class DatabaseUITester {
  constructor() {
    this.browser = null;
    this.page = null;
    this.testResults = {
      passed: 0,
      failed: 0,
      errors: [],
      timestamps: {},
    };
  }

  async initialize() {
    console.log("üöÄ Inicjalizacja test√≥w bazy danych przez UI...");

    this.browser = await puppeteer.launch({
      headless: CONFIG.HEADLESS,
      slowMo: CONFIG.SLOW_MO,
      defaultViewport: { width: 1920, height: 1080 },
      args: ["--no-sandbox", "--disable-setuid-sandbox"],
    });

    this.page = await this.browser.newPage();

    // Ustawienie timeout
    this.page.setDefaultTimeout(CONFIG.TIMEOUT);

    // Nas≈Çuchiwanie b≈Çƒôd√≥w konsoli
    this.page.on("console", (msg) => {
      if (msg.type() === "error") {
        console.log("‚ùå Console Error:", msg.text());
        this.testResults.errors.push(`Console: ${msg.text()}`);
      }
    });

    // Nas≈Çuchiwanie b≈Çƒôd√≥w sieci
    this.page.on("requestfailed", (request) => {
      console.log(
        "‚ùå Network Error:",
        request.url(),
        request.failure().errorText
      );
      this.testResults.errors.push(
        `Network: ${request.url()} - ${request.failure().errorText}`
      );
    });

    await this.page.goto(CONFIG.APP_URL);
    await this.waitForApp();

    console.log("‚úÖ Aplikacja za≈Çadowana pomy≈õlnie");
  }

  async waitForApp() {
    // Czekaj na za≈Çadowanie g≈Ç√≥wnej aplikacji
    await this.page.waitForSelector(
      '[data-testid="app"], .ant-layout, #root > div',
      {
        timeout: CONFIG.TIMEOUT,
      }
    );

    // Dodatkowe czekanie na pe≈Çne za≈Çadowanie
    await this.page.waitForTimeout(2000);
  }

  async takeScreenshot(name) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const filename = `${name}_${timestamp}.png`;
    await this.page.screenshot({
      path: join(CONFIG.SCREENSHOT_DIR, filename),
      fullPage: true,
    });
    console.log(`üì∏ Screenshot: ${filename}`);
  }

  async testConnection() {
    console.log("\nüîå Test: Sprawdzanie po≈ÇƒÖczenia z backendem...");

    try {
      const response = await fetch(`${CONFIG.BACKEND_URL}/health`);
      if (response.ok) {
        console.log("‚úÖ Backend dostƒôpny");
        this.testResults.passed++;
      } else {
        throw new Error(`Backend nie odpowiada: ${response.status}`);
      }
    } catch (error) {
      console.log("‚ùå Backend niedostƒôpny:", error.message);
      this.testResults.failed++;
      this.testResults.errors.push(`Backend connection: ${error.message}`);
    }
  }

  async navigateToPage(pageName) {
    console.log(`üß≠ Nawigacja do strony: ${pageName}`);

    // Sprawd≈∫ czy istnieje menu/sidebar
    const menuSelectors = [
      `[data-testid="nav-${pageName}"]`,
      `a[href*="${pageName.toLowerCase()}"]`,
      `a:contains("${pageName}")`,
      `.ant-menu-item:contains("${pageName}")`,
      `[data-cy="nav-${pageName}"]`,
    ];

    let navigated = false;

    for (const selector of menuSelectors) {
      try {
        await this.page.waitForSelector(selector, { timeout: 2000 });
        await this.page.click(selector);
        navigated = true;
        break;
      } catch (error) {
        // Kontynuuj z nastƒôpnym selektorem
        continue;
      }
    }

    if (!navigated) {
      // Spr√≥buj bezpo≈õredniej nawigacji URL
      const pageUrls = {
        Projekty: "/projects",
        Klienci: "/clients",
        Magazyn: "/magazyn",
      };

      if (pageUrls[pageName]) {
        await this.page.goto(`${CONFIG.APP_URL}${pageUrls[pageName]}`);
        navigated = true;
      }
    }

    if (navigated) {
      await this.page.waitForTimeout(1000);
      console.log(`‚úÖ Przeszed≈Ç do strony: ${pageName}`);
    } else {
      throw new Error(`Nie mo≈ºna przej≈õƒá do strony: ${pageName}`);
    }
  }

  async testCreateProject() {
    console.log("\nüìã Test: Tworzenie nowego projektu...");
    this.testResults.timestamps.createProject = Date.now();

    try {
      await this.navigateToPage("Projekty");
      await this.takeScreenshot("projects_before");

      // Znajd≈∫ przycisk dodawania projektu
      const addButtonSelectors = [
        '[data-testid="add-project"]',
        'button:contains("Dodaj projekt")',
        'button:contains("Nowy projekt")',
        '.ant-btn-primary:contains("Dodaj")',
        '[data-cy="add-project"]',
      ];

      let addButton = null;
      for (const selector of addButtonSelectors) {
        try {
          await this.page.waitForSelector(selector, { timeout: 2000 });
          addButton = selector;
          break;
        } catch (error) {
          continue;
        }
      }

      if (addButton) {
        await this.page.click(addButton);
        console.log("‚úÖ Klikniƒôto przycisk dodawania projektu");
      } else {
        throw new Error("Nie znaleziono przycisku dodawania projektu");
      }

      // Czekaj na modal/drawer
      await this.page.waitForSelector(".ant-drawer, .ant-modal", {
        timeout: 5000,
      });

      // Wype≈Çnij formularz
      const nameInput = await this.page.$(
        'input[name="name"], input[placeholder*="nazwa"], #name'
      );
      if (nameInput) {
        await nameInput.click();
        await nameInput.type(CONFIG.TEST_DATA.project.name);
        console.log(
          `‚úÖ Wprowadzono nazwƒô projektu: ${CONFIG.TEST_DATA.project.name}`
        );
      }

      const descInput = await this.page.$(
        'textarea[name="description"], textarea[placeholder*="opis"], #description'
      );
      if (descInput) {
        await descInput.click();
        await descInput.type(CONFIG.TEST_DATA.project.description);
        console.log("‚úÖ Wprowadzono opis projektu");
      }

      // Zapisz projekt
      const saveSelectors = [
        'button:contains("Zapisz")',
        'button:contains("Dodaj")',
        'button[type="submit"]',
        ".ant-btn-primary",
      ];

      for (const selector of saveSelectors) {
        try {
          await this.page.waitForSelector(selector, { timeout: 2000 });
          await this.page.click(selector);
          console.log("‚úÖ Klikniƒôto przycisk zapisywania");
          break;
        } catch (error) {
          continue;
        }
      }

      // Czekaj na zamkniƒôcie modala i od≈õwie≈ºenie listy
      await this.page.waitForTimeout(2000);
      await this.takeScreenshot("projects_after_add");

      // Sprawd≈∫ czy projekt zosta≈Ç dodany
      const projectExists = await this.page.evaluate((projectName) => {
        return document.body.innerText.includes(projectName);
      }, CONFIG.TEST_DATA.project.name);

      if (projectExists) {
        console.log("‚úÖ Projekt zosta≈Ç pomy≈õlnie utworzony i wy≈õwietlony");
        this.testResults.passed++;
      } else {
        throw new Error("Projekt nie zosta≈Ç wy≈õwietlony na li≈õcie");
      }
    } catch (error) {
      console.log("‚ùå B≈ÇƒÖd podczas tworzenia projektu:", error.message);
      this.testResults.failed++;
      this.testResults.errors.push(`Create Project: ${error.message}`);
      await this.takeScreenshot("projects_error");
    }
  }

  async testCreateClient() {
    console.log("\nüë§ Test: Tworzenie nowego klienta...");
    this.testResults.timestamps.createClient = Date.now();

    try {
      await this.navigateToPage("Klienci");
      await this.takeScreenshot("clients_before");

      // Znajd≈∫ przycisk dodawania klienta
      const addButtonSelectors = [
        '[data-testid="add-client"]',
        'button:contains("Dodaj klienta")',
        'button:contains("Nowy klient")',
        ".ant-btn-primary",
      ];

      let addButton = null;
      for (const selector of addButtonSelectors) {
        try {
          await this.page.waitForSelector(selector, { timeout: 2000 });
          addButton = selector;
          break;
        } catch (error) {
          continue;
        }
      }

      if (addButton) {
        await this.page.click(addButton);
        console.log("‚úÖ Klikniƒôto przycisk dodawania klienta");
      } else {
        throw new Error("Nie znaleziono przycisku dodawania klienta");
      }

      // Czekaj na modal/drawer
      await this.page.waitForSelector(".ant-drawer, .ant-modal", {
        timeout: 5000,
      });

      // Wype≈Çnij formularz klienta
      const nameInput = await this.page.$(
        'input[name="name"], input[placeholder*="nazwa"], #name'
      );
      if (nameInput) {
        await nameInput.click();
        await nameInput.type(CONFIG.TEST_DATA.client.name);
        console.log(
          `‚úÖ Wprowadzono nazwƒô klienta: ${CONFIG.TEST_DATA.client.name}`
        );
      }

      const emailInput = await this.page.$(
        'input[name="email"], input[type="email"], #email'
      );
      if (emailInput) {
        await emailInput.click();
        await emailInput.type(CONFIG.TEST_DATA.client.email);
        console.log("‚úÖ Wprowadzono email klienta");
      }

      const phoneInput = await this.page.$(
        'input[name="phone"], input[placeholder*="telefon"], #phone'
      );
      if (phoneInput) {
        await phoneInput.click();
        await phoneInput.type(CONFIG.TEST_DATA.client.phone);
        console.log("‚úÖ Wprowadzono telefon klienta");
      }

      // Zapisz klienta
      const saveSelectors = [
        'button:contains("Zapisz")',
        'button:contains("Dodaj")',
        'button[type="submit"]',
        ".ant-btn-primary",
      ];

      for (const selector of saveSelectors) {
        try {
          await this.page.waitForSelector(selector, { timeout: 2000 });
          await this.page.click(selector);
          console.log("‚úÖ Klikniƒôto przycisk zapisywania klienta");
          break;
        } catch (error) {
          continue;
        }
      }

      await this.page.waitForTimeout(2000);
      await this.takeScreenshot("clients_after_add");

      // Sprawd≈∫ czy klient zosta≈Ç dodany
      const clientExists = await this.page.evaluate((clientName) => {
        return document.body.innerText.includes(clientName);
      }, CONFIG.TEST_DATA.client.name);

      if (clientExists) {
        console.log("‚úÖ Klient zosta≈Ç pomy≈õlnie utworzony");
        this.testResults.passed++;
      } else {
        throw new Error("Klient nie zosta≈Ç wy≈õwietlony na li≈õcie");
      }
    } catch (error) {
      console.log("‚ùå B≈ÇƒÖd podczas tworzenia klienta:", error.message);
      this.testResults.failed++;
      this.testResults.errors.push(`Create Client: ${error.message}`);
      await this.takeScreenshot("clients_error");
    }
  }

  async testCreateMaterial() {
    console.log("\nüì¶ Test: Tworzenie nowego materia≈Çu...");
    this.testResults.timestamps.createMaterial = Date.now();

    try {
      await this.navigateToPage("Magazyn");
      await this.takeScreenshot("materials_before");

      // Znajd≈∫ przycisk dodawania materia≈Çu
      const addButtonSelectors = [
        '[data-testid="add-material"]',
        'button:contains("Dodaj materia≈Ç")',
        'button:contains("Nowy materia≈Ç")',
        ".ant-btn-primary",
      ];

      let addButton = null;
      for (const selector of addButtonSelectors) {
        try {
          await this.page.waitForSelector(selector, { timeout: 2000 });
          addButton = selector;
          break;
        } catch (error) {
          continue;
        }
      }

      if (addButton) {
        await this.page.click(addButton);
        console.log("‚úÖ Klikniƒôto przycisk dodawania materia≈Çu");
      } else {
        throw new Error("Nie znaleziono przycisku dodawania materia≈Çu");
      }

      // Czekaj na modal/drawer
      await this.page.waitForSelector(".ant-drawer, .ant-modal", {
        timeout: 5000,
      });

      // Wype≈Çnij formularz materia≈Çu
      const nameInput = await this.page.$(
        'input[name="name"], input[placeholder*="nazwa"], #name'
      );
      if (nameInput) {
        await nameInput.click();
        await nameInput.type(CONFIG.TEST_DATA.material.name);
        console.log(
          `‚úÖ Wprowadzono nazwƒô materia≈Çu: ${CONFIG.TEST_DATA.material.name}`
        );
      }

      // Zapisz materia≈Ç
      const saveSelectors = [
        'button:contains("Zapisz")',
        'button:contains("Dodaj")',
        'button[type="submit"]',
        ".ant-btn-primary",
      ];

      for (const selector of saveSelectors) {
        try {
          await this.page.waitForSelector(selector, { timeout: 2000 });
          await this.page.click(selector);
          console.log("‚úÖ Klikniƒôto przycisk zapisywania materia≈Çu");
          break;
        } catch (error) {
          continue;
        }
      }

      await this.page.waitForTimeout(2000);
      await this.takeScreenshot("materials_after_add");

      // Sprawd≈∫ czy materia≈Ç zosta≈Ç dodany
      const materialExists = await this.page.evaluate((materialName) => {
        return document.body.innerText.includes(materialName);
      }, CONFIG.TEST_DATA.material.name);

      if (materialExists) {
        console.log("‚úÖ Materia≈Ç zosta≈Ç pomy≈õlnie utworzony");
        this.testResults.passed++;
      } else {
        throw new Error("Materia≈Ç nie zosta≈Ç wy≈õwietlony na li≈õcie");
      }
    } catch (error) {
      console.log("‚ùå B≈ÇƒÖd podczas tworzenia materia≈Çu:", error.message);
      this.testResults.failed++;
      this.testResults.errors.push(`Create Material: ${error.message}`);
      await this.takeScreenshot("materials_error");
    }
  }

  async testDataPersistence() {
    console.log("\nüíæ Test: Trwa≈Ço≈õƒá danych po od≈õwie≈ºeniu...");
    this.testResults.timestamps.persistence = Date.now();

    try {
      // Od≈õwie≈º stronƒô
      await this.page.reload();
      await this.waitForApp();
      await this.page.waitForTimeout(3000);

      console.log("‚úÖ Strona zosta≈Ça od≈õwie≈ºona");

      // Sprawd≈∫ czy projekt nadal istnieje
      await this.navigateToPage("Projekty");
      const projectExists = await this.page.evaluate((projectName) => {
        return document.body.innerText.includes(projectName);
      }, CONFIG.TEST_DATA.project.name);

      if (projectExists) {
        console.log("‚úÖ Projekt zachowany po od≈õwie≈ºeniu");
      } else {
        throw new Error("Projekt nie zosta≈Ç zachowany");
      }

      // Sprawd≈∫ czy klient nadal istnieje
      await this.navigateToPage("Klienci");
      const clientExists = await this.page.evaluate((clientName) => {
        return document.body.innerText.includes(clientName);
      }, CONFIG.TEST_DATA.client.name);

      if (clientExists) {
        console.log("‚úÖ Klient zachowany po od≈õwie≈ºeniu");
      } else {
        throw new Error("Klient nie zosta≈Ç zachowany");
      }

      // Sprawd≈∫ czy materia≈Ç nadal istnieje
      await this.navigateToPage("Magazyn");
      const materialExists = await this.page.evaluate((materialName) => {
        return document.body.innerText.includes(materialName);
      }, CONFIG.TEST_DATA.material.name);

      if (materialExists) {
        console.log("‚úÖ Materia≈Ç zachowany po od≈õwie≈ºeniu");
      } else {
        throw new Error("Materia≈Ç nie zosta≈Ç zachowany");
      }

      await this.takeScreenshot("persistence_test");
      this.testResults.passed++;
    } catch (error) {
      console.log("‚ùå B≈ÇƒÖd podczas testu trwa≈Ço≈õci:", error.message);
      this.testResults.failed++;
      this.testResults.errors.push(`Data Persistence: ${error.message}`);
    }
  }

  async testDatabaseReconnection() {
    console.log("\nüîÑ Test: Ponowne po≈ÇƒÖczenie z bazƒÖ danych...");
    this.testResults.timestamps.reconnection = Date.now();

    try {
      // Symulacja roz≈ÇƒÖczenia - sprawdzenie czy dane sƒÖ nadal dostƒôpne
      console.log('üîå Sprawdzanie stanu po "roz≈ÇƒÖczeniu"...');

      // Czekaj chwilƒô i sprawd≈∫ ponownie dane
      await this.page.waitForTimeout(2000);

      // Przejd≈∫ przez wszystkie sekcje i sprawd≈∫ dane
      await this.navigateToPage("Projekty");
      const projectStillExists = await this.page.evaluate((projectName) => {
        return document.body.innerText.includes(projectName);
      }, CONFIG.TEST_DATA.project.name);

      if (projectStillExists) {
        console.log("‚úÖ Dane projekt√≥w dostƒôpne po ponownym po≈ÇƒÖczeniu");
        this.testResults.passed++;
      } else {
        throw new Error("Dane projekt√≥w niedostƒôpne");
      }
    } catch (error) {
      console.log("‚ùå B≈ÇƒÖd podczas testu ponownego po≈ÇƒÖczenia:", error.message);
      this.testResults.failed++;
      this.testResults.errors.push(`Database Reconnection: ${error.message}`);
    }
  }

  async generateReport() {
    console.log("\nüìä Generowanie raportu test√≥w...");

    const totalTests = this.testResults.passed + this.testResults.failed;
    const successRate =
      totalTests > 0
        ? ((this.testResults.passed / totalTests) * 100).toFixed(2)
        : 0;

    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        total: totalTests,
        passed: this.testResults.passed,
        failed: this.testResults.failed,
        successRate: `${successRate}%`,
      },
      testDuration: {
        total: Date.now() - this.testResults.timestamps.createProject,
        createProject:
          this.testResults.timestamps.createClient -
          this.testResults.timestamps.createProject,
        createClient:
          this.testResults.timestamps.createMaterial -
          this.testResults.timestamps.createClient,
        createMaterial:
          this.testResults.timestamps.persistence -
          this.testResults.timestamps.createMaterial,
        persistence:
          this.testResults.timestamps.reconnection -
          this.testResults.timestamps.persistence,
        reconnection: Date.now() - this.testResults.timestamps.reconnection,
      },
      errors: this.testResults.errors,
      testData: CONFIG.TEST_DATA,
    };

    // Zapisz raport do pliku
    const fs = await import("fs");
    const reportPath = join(__dirname, "database-test-report.json");
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    console.log("\n=".repeat(80));
    console.log("üìã RAPORT TEST√ìW BAZY DANYCH");
    console.log("=".repeat(80));
    console.log(
      `üìä Podsumowanie: ${this.testResults.passed}/${totalTests} test√≥w przesz≈Ço (${successRate}%)`
    );
    console.log(
      `‚è±Ô∏è  Czas trwania: ${(report.testDuration.total / 1000).toFixed(2)}s`
    );

    if (this.testResults.errors.length > 0) {
      console.log("\n‚ùå B≈Çƒôdy:");
      this.testResults.errors.forEach((error, index) => {
        console.log(`  ${index + 1}. ${error}`);
      });
    }

    console.log(`\nüíæ Pe≈Çny raport zapisany: ${reportPath}`);
    console.log("=".repeat(80));

    return report;
  }

  async runAllTests() {
    try {
      await this.initialize();

      // Uruchom testy w sekwencji
      await this.testConnection();
      await this.testCreateProject();
      await this.testCreateClient();
      await this.testCreateMaterial();
      await this.testDataPersistence();
      await this.testDatabaseReconnection();

      // Finalne screenshot
      await this.takeScreenshot("final_state");

      // Wygeneruj raport
      const report = await this.generateReport();

      return report;
    } catch (error) {
      console.log("üí• Krytyczny b≈ÇƒÖd podczas test√≥w:", error.message);
      this.testResults.errors.push(`Critical: ${error.message}`);
      await this.takeScreenshot("critical_error");
    } finally {
      if (this.browser) {
        await this.browser.close();
        console.log("üîí PrzeglƒÖdarka zamkniƒôta");
      }
    }
  }
}

// Uruchom testy
async function main() {
  const tester = new DatabaseUITester();
  await tester.runAllTests();
}

// Eksportuj klasƒô dla u≈ºycia w innych skryptach
export { CONFIG, DatabaseUITester };

// Uruchom je≈õli skrypt wywo≈Çany bezpo≈õrednio
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}
